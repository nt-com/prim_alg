////////////////////////////////////////////////////
// Prims's Algorithm - Main File
// NOTE: 	compiled with g++ under Linux
//				no memory leaks detected by valgrind
////////////////////////////////////////////////////

/// @file main.cpp
/// @brief the main file, contains prim's algorithm

////////////////////////////////////////////////////
// LIBRARIES
////////////////////////////////////////////////////

#include <iostream>
#include <ctime>
#include "graph.h"
#include "prim.h"

// NAMESPACE
using namespace std;

////////////////////////////////////////////////////
// FUNCTION PROTOTYPES
////////////////////////////////////////////////////
/// @brief Prim's Algorithm
/// @param g a connected graph to apply the algorithm to
/// @return a prim class containing the data generated by prim's algorithm
prim primsAlgorithm(graph &g); 

////////////////////////////////////////////////////
// MAIN FUNCTION
////////////////////////////////////////////////////

int main(void) {

	// seed the random number generator
	srand(time(0));

	// set the source node for dijkstra's algorithm
	unsigned int sourceNode = 0;

	// create a random graph g, show it's adjacency matrix
	graph g(g_GRAPH_SIZE);
	// always generates a fully connected graph
	g.generate();
	g.print();
	
	// apply prim's algorithm to the graph, 
	// print the minimal spanning tree
	prim primResult = primsAlgorithm(g);
	primResult.print();

	return 0;

}

////////////////////////////////////////////////////
// FUNCTIONS
////////////////////////////////////////////////////

prim primsAlgorithm(graph &g) {

	int currentNode = g_UNDEFINED;
	unsigned int edgeValue = g_INFINITY;
	
	// initialization of values is done by constructor
	prim p(g.getSize());	

	// change one key value so the node gets picked
	p.setKeyValue(0,0);	
	p.setParent(0, g_UNDEFINED);

	cout << "Starting Prim's Algorithm" << endl;

	for(int v = 0; v < g.getSize() - 1; v++) {

		// get the node with the minimum key value
		currentNode = p.getMinKey();

		// set node as included in spanning tree
		p.setSpTree(currentNode);

		// update adjacent vertices
		for(int n = 0; n < g.getSize(); n++) {

			edgeValue = g.getWeight(currentNode, n);
			// if there is an edge between the current node and another node
			if( edgeValue ) {
				// if a node is not yet included in spanning tree 
				// if the edge value is smaller than the key value update
				if( (p.getSpTree(n) == false) && (edgeValue < p.getKeyValue(n)) ) {
					p.setParent(n, currentNode);
					p.setKeyValue(n, edgeValue);
				}
			} // if edgeValue

		} // for inner (n)
			
	} // for outer (v)	

	return p;

}

////////////////////////////////////////////////////
// EOF
////////////////////////////////////////////////////
